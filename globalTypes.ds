CHUNK_WIDTH :: 16
CHUNK_HEIGHT :: 32

@Serializeable
Vector3 :: struct
{
    @c2s @s2c x : uint32_t;
    @c2s @s2c y : uint32_t;
    @c2s @s2c z : uint32_t;
}

@Serializeable
Player :: struct
{
    @c2s @s2c name : [20]char;
    @c2s @s2c uuid : uint64_t;
    @s2c health : int16_t;
}

PlayerLinkedListNode :: struct
{
    // maybe add a mutex
    player_pointer : *Player;
    next : *PlayerLinkedListNode;
}

@Serializeable
Chunk :: struct
{
    @s2c blocks : [CHUNK_WIDTH * CHUNK_WIDTH * CHUNK_HEIGHT]uint8_t;
    PlayerLinkedList : *PlayerLinkedListNode;
}

// Enumerate all the different packet types
PlayerPacketType :: enum 
{
    // For sending a player's state, from the client, data is only accepted about that client's
    // username, UUID, and settings; however the server can send all of the relevant info including
    // Position, velocity, equipment / items, alligance, as well as everything the client is allowed to send.
    PLAYER_DATA_PACKET,
    // For authenticating wether or not the peer has any business controlling the specified UUID
    // May use RSA signing for this and store public keys in the database with other player data
    // The server will send a challenge packet which the client is to sign and return, and the server
    // will verify and reset the peer if they do not respond or respond incorrectly
    PLAYER_AUTH_PACKET,
    // This is for actions such as foreward key pressed etc. which are likely to be exclusively client -> server
    PLAYER_VERB_PACKET,
};